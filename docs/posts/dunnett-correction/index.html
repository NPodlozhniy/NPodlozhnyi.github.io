<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Dunnett&#39;s Correction for ABC testing | Nikita Podlozhniy</title>
<meta name="keywords" content="">
<meta name="description" content="Background We at HomeBuddy run a various number of AB tests to improve customer journey. A big part of efforts is allocated to onboarding funnel, hence the main metrics are conversions throughout this funnel. Usually we design multivariate tests with a few testing groups reflecting slightly different variations (often in terms of actual design) of the business hypothesis behind. No matter how you run the experiments you want to get accurate and powerful procedure, that&rsquo;s why we use Dunnett&rsquo;s correction for all of the experiments that we have to maximize the power of AB engine.">
<meta name="author" content="Nikita Podlozhniy">
<link rel="canonical" href="https://npodlozhniy.github.io/posts/dunnett-correction/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.5c25c975546c048d1a5600aadb48425ae1bc921a9a18fe67d6955c9535260811.css" integrity="" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.acb54fd32bbc1982428b8850317e45d076b95012730a5936667e6bc21777692a.js" integrity="sha256-rLVP0yu8GYJCi4hQMX5F0Ha5UBJzClk2Zn5rwhd3aSo="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://npodlozhniy.github.io/favicons/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://npodlozhniy.github.io/favicons/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://npodlozhniy.github.io/favicons/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://npodlozhniy.github.io/favicons/apple-touch-icon.png">
<link rel="mask-icon" href="https://npodlozhniy.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://npodlozhniy.github.io/posts/dunnett-correction/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" integrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" integrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"
    onload="renderMathInElement(document.body, 
    {
              delimiters: [
                  {left: '$$', right: '$$', display: true},
                  {left: '\\[', right: '\\]', display: true},
                  {left: '$', right: '$', display: false},
                  {left: '\\(', right: '\\)', display: false}
              ]
          }
    );"></script>



<script src="https://cdn.plot.ly/plotly-2.11.1.min.js"></script>

<script async src="https://www.googletagmanager.com/gtag/js?id=G-ESWD18X008"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-ESWD18X008', { 'anonymize_ip': false });
}
</script>
<meta property="og:title" content="Dunnett&#39;s Correction for ABC testing" />
<meta property="og:description" content="Background We at HomeBuddy run a various number of AB tests to improve customer journey. A big part of efforts is allocated to onboarding funnel, hence the main metrics are conversions throughout this funnel. Usually we design multivariate tests with a few testing groups reflecting slightly different variations (often in terms of actual design) of the business hypothesis behind. No matter how you run the experiments you want to get accurate and powerful procedure, that&rsquo;s why we use Dunnett&rsquo;s correction for all of the experiments that we have to maximize the power of AB engine." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://npodlozhniy.github.io/posts/dunnett-correction/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-28T00:00:00+00:00" />
<meta property="article:modified_time" content="2023-07-28T00:00:00+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Dunnett&#39;s Correction for ABC testing"/>
<meta name="twitter:description" content="Background We at HomeBuddy run a various number of AB tests to improve customer journey. A big part of efforts is allocated to onboarding funnel, hence the main metrics are conversions throughout this funnel. Usually we design multivariate tests with a few testing groups reflecting slightly different variations (often in terms of actual design) of the business hypothesis behind. No matter how you run the experiments you want to get accurate and powerful procedure, that&rsquo;s why we use Dunnett&rsquo;s correction for all of the experiments that we have to maximize the power of AB engine."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://npodlozhniy.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Dunnett's Correction for ABC testing",
      "item": "https://npodlozhniy.github.io/posts/dunnett-correction/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Dunnett's Correction for ABC testing",
  "name": "Dunnett\u0027s Correction for ABC testing",
  "description": "Background We at HomeBuddy run a various number of AB tests to improve customer journey. A big part of efforts is allocated to onboarding funnel, hence the main metrics are conversions throughout this funnel. Usually we design multivariate tests with a few testing groups reflecting slightly different variations (often in terms of actual design) of the business hypothesis behind. No matter how you run the experiments you want to get accurate and powerful procedure, that\u0026rsquo;s why we use Dunnett\u0026rsquo;s correction for all of the experiments that we have to maximize the power of AB engine.",
  "keywords": [
    
  ],
  "articleBody": "Background We at HomeBuddy run a various number of AB tests to improve customer journey. A big part of efforts is allocated to onboarding funnel, hence the main metrics are conversions throughout this funnel. Usually we design multivariate tests with a few testing groups reflecting slightly different variations (often in terms of actual design) of the business hypothesis behind. No matter how you run the experiments you want to get accurate and powerful procedure, that’s why we use Dunnett’s correction for all of the experiments that we have to maximize the power of AB engine. Are you curious what it is?\nPrerequisites It’s expected that the reader has an experience with Python and its main libraries for data analysis. The actual notebook was written on Python 3.11.4 and to keep the results reproducible here is the list of particular packages that are being used in the article specified with their versions.\nCode\rpip install --quiet --upgrade numpy==1.25.2 scipy==1.11.2 statsmodels==0.14.0 podlozhnyy_module==2.4b0 Problem Definition Imagine we want to optimize an onboarding funnel of an arbitrary product applying a new business idea. We don’t want to rely on expert assessment only and hence opt for designing an AB test first. The target metric is an abstract conversion and we carry out a classical AB test with one treatment group.\nIt’s not a secret that in such a scenario the best practice is a standard Z-test procedure for independent proportions\n$$ Z = \\frac{\\hat{p}_1 - \\hat{p}_2}{\\sqrt{P(1 - P)(\\frac{1}{n_1} + \\frac{1}{n_2})}} \\space\\text{,where}\\space P = \\frac{\\hat{p}_1n_1 + \\hat{p}_2n_2}{n_1 + n_2} $$\nUnder the conditions of the truth of the null hypothesis statistic follows standard normal distribution\n$$ Z \\stackrel{H_0}{\\sim} \\mathbb{N}(0, 1) $$\nCode\rimport numpy as np from scipy.stats import binom from statsmodels.stats.proportion import proportions_ztest, proportion_confint There are multiple versions of classical Z-test in Python and even though those have its unique selling points this time I apply my own implementation to stay consistent across this article using the same interface for all criteria.\nCode\rfrom podlozhnyy_module.abtesting import Dunnett, Ztest Interface As a brief check that the method is working as expected and to make you acquainted with its interface let’s identify a dummy experiment\ninput must consist of at least three lists:\nbase is the basis event that stands as a denominator of conversion target is the goal event - conversion numerator groups are names of the experiment variants In addition variant is specified to explicitly define which group we’re focus on (it makes sense in case of multivariate testing)\nCode\rinput = { \"base\": [ 480, 437, ], \"target\": [ 32, 37, ], \"groups\": [ \"test\", \"control\", ], \"variant\": \"test\", } Functionality is written leveraging well-known OOP principles, so the experiment is not a function that stands aside, but a class which besides input dictionary gets the keys of the corresponding entities.\nCode\rtest = Ztest(input, base=\"base\", target=\"target\", groups=\"groups\", variant=\"variant\") print(f\"p-value: {test.variant_pvalue(alternative='less'):.3f}, Z-statistic: {test.statistic[0]:.3f}\") p-value: 0.151, Z-statistic: -1.032\rFor on the fly verification, the results might be compared to the output of well known statsmodels package.\nCode\rcount = input[\"target\"] nobs = input[\"base\"] stat, pval = proportions_ztest(count, nobs, alternative='smaller') print('p-value: {0:0.3f}, Z-statistic: {1:0.3f}'.format(pval, stat)) p-value: 0.151, Z-statistic: -1.032\rThe numbers coincide and now we’re ready to move to the main topic.\nTheory While often basic Z-test procedure is the appropriate option for AB analysis, it doesn’t satisfy the genuine requirements for the statistical method when it comes to multiple hypothesis testing. I hope you understand what is the problem in case of having $n$ independent metrics in your test: if you set up acceptable Type I error rate $\\alpha$ for each of them then the total probability to get at least one significant difference (dabbed as FWER) under the conditions of the truth of the null hypothesis (which means no difference between the groups by design) would be not $\\alpha$ but $1 - (1 - \\alpha)^n$ what totally invalidates the procedure.\nThere are two possible scenarios: either we have multiple metrics that we want to compare across the test and control group or we have several testing groups that apply different treatment to customers. Whilst the first option is more popular by a wide margin and has lots of solutions, the second one is often undercovered in the business industry and generally the same procedures are used. If you apply any type of corrections for multiple testing you’re already ahead of 80% of teams that don’t, although what I want to show you is that the second scenario must be treated differently to extract more insights from your experiments.\nDunnet’s test is a multiple comparison procedure developed specifically to compare each of a number of treatment groups to a control one, extended original paper was released in 1964. Dunnett’s test is not a set aside procedure but more like an extension of monumental Student’s T-test, for a specific design where every treatment group is compared to a single control one, which is leveraged to take into account the dependencies between comparisons. In case of proportions it’s a Z-test, as long as we don’t need to estimate variance for binomial distribution in addition to the probability of success.\nThe main trick is to calculate variance in a different way, just to remind you in case of a standard procedure statistic looks like\n$$ Z = \\frac{\\hat{p}_1 - \\hat{p}_2}{S\\sqrt{\\frac{1}{n_1} + \\frac{1}{n_2}}} $$\nwhere $S$ is a standard error estimate comprises the squared root of variance of a combined sample $\\sigma^2 = P(1 - P)$\nDunnett’s test statistic looks exactly the same for every treatment group with the only difference laying under how variance is calculated. In general in case of $n$ treatment groups and one control group $i=0$ of observations $(X_0, .. X_{N_i})$ with $N_i$ size of each, the formula is the following:\n$$ S^{2} = \\frac{\\sum_{i=0}^{n}S_i^2}{df} = \\frac{\\sum_{i=0}^{n}\\sum_{j=1}^{N_i}(X_{ij} - \\bar{X_i})^2}{df} = \\frac{\\sum_{i=0}^{n}\\sum_{j=1}^{N_i}X_{ij}^2 - n\\bar{X_i}^2}{df} $$\nwhere $df$ is degrees of freedom\n$$ df = \\sum_{i=0}^{n}N_{i} - (n + 1) $$\nFor proportions this “pooled” variance simplifies even further as long as the rest part of calculations is exactly the same\n$$ S^{2} = \\frac{\\sum_{i=0}^{n}{N_i\\bar{p_i}(1 - \\bar{p_i})}}{df} $$\nCanonical AB test First of all, to guarantee the accuracy we should challenge this specific criterion against a classical one in case when both of them are applicable - standard AB test. What is good about proportions we can easily simulate the data in the blink of an eye, so we’re setting up a simulation and employ Monte Carlo process to check two things:\ncorrectness - the criterion should meet the identified confidence level, which means that in case of AA comparison we should get Type I error in $\\alpha$ percent of experiments power - as it comes from the theory in case of only two groups Dunnett’s test is equal to a classical Z-test, so shall we call the implementation out? In addition to point estimate of False Positive Rate I offer to build 90% confidence interval to be more precise in the comparisons\nCode\rdef generate_sample(size: int, prob: float) -\u003e int: \"\"\" Return the number of target events \"\"\" return binom(n=size, p=prob).rvs() Correctness in AA Code\rnp.random.seed(2024) alpha = 0.05 n_iterations = 1000 p_general = 0.1 input = dict.fromkeys([\"base\", \"target\", \"names\", \"variant\"]) input[\"names\"] = [\"A\", \"B\"] input[\"variant\"] = \"B\" for size in map(int, [1e2, 1e3, 1e4]): dunnett_positives = 0 z_positives = 0 for i in range(n_iterations): input[\"base\"] = [size, size] input[\"target\"] = [generate_sample(size, p_general), generate_sample(size, p_general)] dunnett_test = Dunnett(input, \"base\", \"target\", \"names\", \"variant\") z_test = Ztest(input, \"base\", \"target\", \"names\", \"variant\") dunnett_p_value = dunnett_test.variant_pvalue(alternative=\"two-sided\") z_p_value = z_test.variant_pvalue(alternative=\"two-sided\") if dunnett_p_value \u003c= alpha: dunnett_positives += 1 if z_p_value \u003c= alpha: z_positives += 1 print(f'FPR for sample size {size}') l, r = proportion_confint(count=dunnett_positives, nobs=n_iterations, alpha=0.10, method='wilson') print(f'Dunnet: {dunnett_positives / n_iterations:.3f} ± {(r - l) / 2:.3f}') l, r = proportion_confint(count=z_positives, nobs=n_iterations, alpha=0.10, method='wilson') print(f'Z-test: {z_positives / n_iterations:.3f} ± {(r - l) / 2:.3f}') print() FPR for sample size 100\rDunnet: 0.048 ± 0.011\rZ-test: 0.048 ± 0.011\rFPR for sample size 1000\rDunnet: 0.050 ± 0.011\rZ-test: 0.050 ± 0.011\rFPR for sample size 10000\rDunnet: 0.051 ± 0.011\rZ-test: 0.051 ± 0.011\rAmazing! It seems that 0.05 every time lies in the 90% confidence interval for FPR and hence the criterion is valid and moreover the numbers are exactly the same, it’s what was expected and now let’s check the power too.\nPower in AB Code\rnp.random.seed(2024) alpha = 0.05 n_iterations = 1000 p_general = 0.10 effect_size = 0.2 input = dict.fromkeys([\"base\", \"target\", \"names\", \"variant\"]) input[\"names\"] = [\"A\", \"B\"] input[\"variant\"] = \"B\" for size in map(int, [1e2, 1e3, 1e4]): dunnett_positives = 0 z_positives = 0 for i in range(n_iterations): input[\"base\"] = [size, size] input[\"target\"] = [generate_sample(size, p_general), generate_sample(size, p_general * (1 + effect_size))] dunnett_test = Dunnett(input, \"base\", \"target\", \"names\", \"variant\") z_test = Ztest(input, \"base\", \"target\", \"names\", \"variant\") dunnett_p_value = dunnett_test.variant_pvalue(alternative=\"two-sided\") z_p_value = z_test.variant_pvalue(alternative=\"two-sided\") if dunnett_p_value \u003c= alpha: dunnett_positives += 1 if z_p_value \u003c= alpha: z_positives += 1 print(f'TPR of {effect_size:.0%} effect size for sample size {size}') l, r = proportion_confint(count=dunnett_positives, nobs=n_iterations, alpha=0.10, method='wilson') print(f'Dunnet: {dunnett_positives / n_iterations:.3f} ± {(r - l) / 2:.3f}') l, r = proportion_confint(count=z_positives, nobs=n_iterations, alpha=0.10, method='wilson') print(f'Z-test: {z_positives / n_iterations:.3f} ± {(r - l) / 2:.3f}') print() TPR of 20% effect size for sample size 100\rDunnet: 0.085 ± 0.015\rZ-test: 0.085 ± 0.015\rTPR of 20% effect size for sample size 1000\rDunnet: 0.306 ± 0.024\rZ-test: 0.306 ± 0.024\rTPR of 20% effect size for sample size 10000\rDunnet: 0.992 ± 0.005\rZ-test: 0.992 ± 0.005\rWe are well on our way - the numbers are exactly the same, which means that in the case of 2 groups, Dunnett’s test is at least as powerful as a standard procedure. It’s time to challenge it in a way it’s supposed to be used: meet multivariate testing!\nMultivariate ABC Monte Carlo Now we will track how the criterion controls not a single FPR, but family-wise error rate (FWER) and what is more in order to continue the comparison with a classical Z-test the latter needs to have Bonferroni correction applied otherwise it wouldn’t properly control FWER.\nCode\rdef fwe(x: np.ndarray, alpha: float) -\u003e bool: \"\"\" Indicates either at least one of null hypotheses is rejected \"\"\" return max(x \u003c= alpha) def bonferroni_fwe(x: np.ndarray, alpha: float, n: int) -\u003e bool: \"\"\" Bonferroni correction for FWER, you can think of as it's Bonferroni-Holm procedure Because to have a False Positive result it's necessary and sufficient that at least one of `n` p-values doesn't exceed `alpha` / `n` \"\"\" return fwe(x, alpha / n) To simplify the code in the future Monte Carlo procedure is wrapped into a function with all the necessary parameters supplied as arguments.\nCode\rdef monte_carlo( aa_test: bool = True, verbose: bool = True, n_iterations: int = 1000, group_size: int = 100, n_groups: int = 3, p_general: float = 0.1, effect_size: float = 0.2, alpha: float = 0.05, ) -\u003e dict: input = dict.fromkeys([\"base\", \"target\", \"names\", \"variant\"]) input[\"names\"] = [chr(ord(\"A\") + i) for i in range(n_groups)] input[\"variant\"] = input[\"names\"][-1] dunnett_positives = 0 z_positives = 0 for i in range(n_iterations): input[\"base\"] = [group_size] * n_groups input[\"target\"] = [generate_sample(group_size, p_general) for _ in range(n_groups - 1)] input[\"target\"] += [generate_sample(group_size, p_general * (1 + effect_size * (1 - aa_test)))] dunnett_test = Dunnett(input, \"base\", \"target\", \"names\", \"variant\") z_test = Ztest(input, \"base\", \"target\", \"names\", \"variant\") dunnett_p_value = dunnett_test.groups_results(alternative=\"two-sided\")[\"p-value\"] z_p_value = z_test.groups_results(alternative=\"two-sided\")[\"p-value\"] if aa_test: if fwe(dunnett_p_value, alpha): dunnett_positives += 1 if bonferroni_fwe(z_p_value, alpha, 2): z_positives += 1 else: if isinstance(dunnett_p_value, np.ndarray) and dunnett_p_value[-1] \u003c= alpha: dunnett_positives += 1 elif isinstance(dunnett_p_value, np.float64) and dunnett_p_value \u003c= alpha: dunnett_positives += 1 if sidak_holm(z_p_value, alpha)[-1]: z_positives += 1 dl, dr = proportion_confint(count=dunnett_positives, nobs=n_iterations, alpha=0.10, method='wilson') zl, zr = proportion_confint(count=z_positives, nobs=n_iterations, alpha=0.10, method='wilson') if verbose: print ( f\"{'FPR' if aa_test else f'TPR of {effect_size:.0%} effect size'} for sample size {group_size}\\n\" f\" - Dunnett: {dunnett_positives / n_iterations:.3f} ± {(dr - dl) / 2:.3f}\\n\" f\" - Z-Test: {z_positives / n_iterations:.3f} ± {(zr - zl) / 2:.3f}\\n\" ) return {\"dunnett\": [dl, dunnett_positives / n_iterations, dr], \"z-test\": [zl, z_positives / n_iterations, zr]} Correctness Validity first, let’s check the ability to control FWER at predefined $\\alpha$ level.\nCode\rnp.random.seed(2024) for size in [1e2, 5e2, 1e3, 5e3]: _ = monte_carlo(aa_test=True, group_size=int(size)) FPR for sample size 100\r- Dunnett: 0.045 ± 0.011\r- Z-Test: 0.042 ± 0.010\rFPR for sample size 500\r- Dunnett: 0.048 ± 0.011\r- Z-Test: 0.045 ± 0.011\rFPR for sample size 1000\r- Dunnett: 0.063 ± 0.013\r- Z-Test: 0.056 ± 0.012\rFPR for sample size 5000\r- Dunnett: 0.050 ± 0.011\r- Z-Test: 0.046 ± 0.011\rSuper cool, both methods: Dunnett’s Test without any corrections and Z-Test with Bonferroni-Holm correction control FWER correctly.\nPower Now it’s the time to define a full fledged step-down procedure for multivariate testing as although its shortened version works well to define FWER it doesn’t when it comes to a power analysis. I prefer Sidak-Holm procedure as it’s known as the most powerful procedure that controls FWER, however as long as sample size is increased the difference from Bonferroni-Holm is hardly noticeable.\nCode\rdef sidak_holm(p_values: np.ndarray, alpha: float) -\u003e np.ndarray: \"\"\" Step down Sidak-Holm procedure If the statistics are jointly independent, no procedure can be constructed to control FWER that is more powerful than the Sidak-Holm method \"\"\" m = p_values.size adjusted_alpha = np.array([1 - (1 - alpha) ** (1 / (m - i + 1)) for i in range(1, m + 1)]) sorted_indexes = np.argsort(p_values) sorted_pvalues = p_values[sorted_indexes] first_reject = (list(sorted_pvalues \u003c= adjusted_alpha) + [False]).index(False) result = np.array([True] * first_reject + [False] * (m - first_reject)) return result[np.argsort(sorted_indexes)] For the power test I offer to use two treatment groups and a single control where in one of the treatments an effect of 20% uplift is added. So the null hypothesis should be rejected and True Positive Rate is measured - is the share of rejected hypotheses among the number of iterations.\nCode\rnp.random.seed(2024) for size in [1e2, 5e2, 1e3, 5e3]: _ = monte_carlo(aa_test=False, group_size=int(size)) TPR of 20% effect size for sample size 100\r- Dunnett: 0.051 ± 0.011\r- Z-Test: 0.043 ± 0.011\rTPR of 20% effect size for sample size 500\r- Dunnett: 0.104 ± 0.016\r- Z-Test: 0.092 ± 0.015\rTPR of 20% effect size for sample size 1000\r- Dunnett: 0.265 ± 0.023\r- Z-Test: 0.240 ± 0.022\rTPR of 20% effect size for sample size 5000\r- Dunnett: 0.855 ± 0.018\r- Z-Test: 0.842 ± 0.019\rThe results are promising! The power of Dunnett’s test every time exceeds the power of Z-test with Sidak-Holm procedure applied. The difference is not significant though, so we can’t say for sure that it’s better, let’s experiment more with parameters and change effect_size\nCode\rnp.random.seed(2024) for effect_size in [0.1, 0.2, 0.3]: _ = monte_carlo(aa_test=False, group_size=3000, effect_size=effect_size) TPR of 10% effect size for sample size 3000\r- Dunnett: 0.163 ± 0.019\r- Z-Test: 0.157 ± 0.019\rTPR of 20% effect size for sample size 3000\r- Dunnett: 0.589 ± 0.026\r- Z-Test: 0.569 ± 0.026\rTPR of 30% effect size for sample size 3000\r- Dunnett: 0.927 ± 0.014\r- Z-Test: 0.914 ± 0.015\rIt’s exciting, the result remains the same, and if we know that Sidak-Holm is the most powerful method that controls FWER for the general use case, we see now that Dunnett’s at least not worse. Finally, the most appealing variable is the number of treatment groups, let’s vary it too.\nCode\rnp.random.seed(2024) for n_groups in [3, 5, 7]: _ = monte_carlo(aa_test=False, group_size=3000, n_groups=n_groups) TPR of 20% effect size for sample size 3000\r- Dunnett: 0.608 ± 0.025\r- Z-Test: 0.601 ± 0.025\rTPR of 20% effect size for sample size 3000\r- Dunnett: 0.544 ± 0.026\r- Z-Test: 0.506 ± 0.026\rTPR of 20% effect size for sample size 3000\r- Dunnett: 0.464 ± 0.026\r- Z-Test: 0.424 ± 0.026\rNow we’ve nailed it! The number of groups is what affects the bottom line. The more groups are in the experiment - the more powerful Dunnett’s Correction than Sidak-Holm. So, let’s build a title image for this article that illustrates how Dunnett’s test outperforms the well-known step-down procedure as the number of treatment groups increases.\nCode\rfrom tqdm.notebook import tqdm np.random.seed(2024) ztest_values = [] dunnett_values = [] for n_groups in tqdm(range(2, 16)): result = monte_carlo(aa_test=False, verbose=False, group_size=3000, n_groups=n_groups) dunnett_values.append(result[\"dunnett\"]) ztest_values.append(result[\"z-test\"]) Plotly is used for interactive visualization, hover over the image to see details.\nCode\rimport plotly.express as px import plotly.graph_objs as go def hex2rgba(hex, alpha): \"\"\" Convert plotly hex colors to rgb and enables transparency adjustment \"\"\" col_hex = hex.lstrip('#') col_rgb = tuple(int(col_hex[i : i + 2], 16) for i in (0, 2, 4)) col_rgb += (alpha,) return 'rgba' + str(col_rgb) def get_new_color(colors): while True: for color in colors: yield color colors_list = px.colors.qualitative.Plotly rgba_colors = [hex2rgba(color, alpha=0.5) for color in colors_list] palette = get_new_color(rgba_colors) def add_chart(figure, data, title): x = list(range(1, 15)) color = next(palette) figure.add_trace( go.Scatter( name=title, x=x, y=[v[1] for v in data], mode='lines', line=dict(color=color), ), ) figure.add_trace( go.Scatter( name='Upper Bound', x=x, y=[v[2] for v in data], mode='lines', line=dict(width=0), marker=dict(color=\"#444\"), hovertemplate=\"%{y:.3f}\", showlegend=False, ), ) figure.add_trace( go.Scatter( name='Lower Bound', x=x, y=[v[0] for v in data], mode='lines', line=dict(width=0), marker=dict(color=\"#444\"), hovertemplate=\"%{y:.3f}\", showlegend=False, fillcolor=color, fill='tonexty', ), ) figure = go.Figure() add_chart(figure, dunnett_values, \"Dunnnett's Correction\") add_chart(figure, ztest_values, 'Z-Test with Sidak-Holm') figure.update_xaxes( title_text=\"Number of Treatment Groups\" ) figure.update_layout( yaxis_title='True Positive Rate', title={ \"x\": 0.5, \"text\": 'Power of Сriterion', }, hovermode=\"x\", template=\"plotly_dark\", ) figure.show() Conclusion It was shown that when the experiment design satisfies the premises of Dunnett’s Test applicability (only $n$ comparisons of $n$ test groups against a single control) at least in a specific case of conversion metrics, Dunnett’s correction is more powerful that the standard step-down procedures like Sidak-Holm.\nWhile Dunnet’s correction is a definite winner it doesn’t mean that Sidak-Holm is abandoned from now on in our team, the proper design would be to use Dunnett’s correction first for multivariate testing and Sidak-Holm procedure must be applied on top if there are multiple metrics to compare between the groups, which is often the case.\nAdditional Information Original Paper from Journal of the American Statistical Association Multivariate Testing - Best Practices Dunnett’s Correction in Analytics ToolKit Multiple comparisons problem ",
  "wordCount" : "3010",
  "inLanguage": "en",
  "datePublished": "2023-07-28T00:00:00Z",
  "dateModified": "2023-07-28T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Nikita Podlozhniy"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://npodlozhniy.github.io/posts/dunnett-correction/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Nikita Podlozhniy",
    "logo": {
      "@type": "ImageObject",
      "url": "https://npodlozhniy.github.io/favicons/favicon.ico"
    }
  }
}
</script>
</head>

<body class=" dark" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://npodlozhniy.github.io/" accesskey="h" title="Nikita Podlozhniy (Alt + H)">Nikita Podlozhniy</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                    <li>
                        <a href="https://npodlozhniy.github.io/ru/" title="Russian"
                            aria-label=":ru:">Ru</a>
                    </li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://npodlozhniy.github.io/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://npodlozhniy.github.io/posts/" title="Posts">
                    <span>Posts</span>
                </a>
            </li>
            <li>
                <a href="https://npodlozhniy.github.io/search" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://npodlozhniy.github.io/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://npodlozhniy.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://npodlozhniy.github.io/posts/">Posts</a></div>
    <h1 class="post-title">
      Dunnett&#39;s Correction for ABC testing
    </h1>
    <div class="post-meta"><span title='2023-07-28 00:00:00 +0000 UTC'>July 28, 2023</span>&nbsp;·&nbsp;15 min&nbsp;·&nbsp;Nikita Podlozhniy

</div>
  </header> <div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#background" aria-label="Background">Background</a><ul>
                        
                <li>
                    <a href="#prerequisites" aria-label="Prerequisites">Prerequisites</a></li></ul>
                </li>
                <li>
                    <a href="#problem-definition" aria-label="Problem Definition">Problem Definition</a><ul>
                        
                <li>
                    <a href="#interface" aria-label="Interface">Interface</a></li></ul>
                </li>
                <li>
                    <a href="#theory" aria-label="Theory">Theory</a></li>
                <li>
                    <a href="#canonical-ab-test" aria-label="Canonical AB test">Canonical AB test</a><ul>
                        
                <li>
                    <a href="#correctness-in-aa" aria-label="Correctness in AA">Correctness in AA</a></li>
                <li>
                    <a href="#power-in-ab" aria-label="Power in AB">Power in AB</a></li></ul>
                </li>
                <li>
                    <a href="#multivariate-abc" aria-label="Multivariate ABC">Multivariate ABC</a><ul>
                        
                <li>
                    <a href="#monte-carlo" aria-label="Monte Carlo">Monte Carlo</a></li>
                <li>
                    <a href="#correctness" aria-label="Correctness">Correctness</a></li>
                <li>
                    <a href="#power" aria-label="Power">Power</a></li></ul>
                </li>
                <li>
                    <a href="#conclusion" aria-label="Conclusion">Conclusion</a></li>
                <li>
                    <a href="#additional-information" aria-label="Additional Information">Additional Information</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="background">Background<a hidden class="anchor" aria-hidden="true" href="#background">#</a></h2>
<p>We at HomeBuddy run a various number of AB tests to improve customer journey.
A big part of efforts is allocated to onboarding funnel, hence the main metrics are conversions throughout this funnel.
Usually we design multivariate tests with a few testing groups reflecting slightly different variations (often in terms of actual design) of the business hypothesis behind.
No matter how you run the experiments you want to get accurate and powerful procedure, that&rsquo;s why we use Dunnett&rsquo;s correction for all of the experiments that we have to maximize the power of AB engine.
Are you curious what it is?</p>
<h3 id="prerequisites">Prerequisites<a hidden class="anchor" aria-hidden="true" href="#prerequisites">#</a></h3>
<p>It&rsquo;s expected that the reader has an experience with Python and its main libraries for data analysis.
The actual notebook was written on Python 3.11.4 and to keep the results reproducible here is the list of particular packages that are being used in the article specified with their versions.</p>
<details>
<summary>Code</summary>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>pip install <span style="color:#f92672">--</span>quiet <span style="color:#f92672">--</span>upgrade numpy<span style="color:#f92672">==</span><span style="color:#ae81ff">1.25.2</span> scipy<span style="color:#f92672">==</span><span style="color:#ae81ff">1.11.2</span> statsmodels<span style="color:#f92672">==</span><span style="color:#ae81ff">0.14.0</span> podlozhnyy_module<span style="color:#f92672">==</span><span style="color:#ae81ff">2.4</span>b0
</span></span></code></pre></div></details>
<h2 id="problem-definition">Problem Definition<a hidden class="anchor" aria-hidden="true" href="#problem-definition">#</a></h2>
<p>Imagine we want to optimize an onboarding funnel of an arbitrary product applying a new business idea.
We don&rsquo;t want to rely on expert assessment only and hence opt for designing an AB test first.
The target metric is an abstract conversion and we carry out a classical AB test with one treatment group.</p>
<p>It&rsquo;s not a secret that in such a scenario the best practice is a standard Z-test procedure for independent proportions</p>
<p>$$ Z = \frac{\hat{p}_1 - \hat{p}_2}{\sqrt{P(1 - P)(\frac{1}{n_1} + \frac{1}{n_2})}} \space\text{,where}\space P  = \frac{\hat{p}_1n_1 + \hat{p}_2n_2}{n_1 + n_2} $$</p>
<p>Under the conditions of the truth of the null hypothesis statistic follows standard normal distribution</p>
<p>$$ Z \stackrel{H_0}{\sim} \mathbb{N}(0, 1) $$</p>
<details>
<summary>Code</summary>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> numpy <span style="color:#66d9ef">as</span> np
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> scipy.stats <span style="color:#f92672">import</span> binom
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> statsmodels.stats.proportion <span style="color:#f92672">import</span> proportions_ztest, proportion_confint
</span></span></code></pre></div></details>
<p>There are multiple versions of classical Z-test in Python and even though those have its unique selling points this time I apply my own implementation to stay consistent across this article using the same interface for all criteria.</p>
<details>
<summary>Code</summary>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">from</span> podlozhnyy_module.abtesting <span style="color:#f92672">import</span> Dunnett, Ztest
</span></span></code></pre></div></details>
<h3 id="interface">Interface<a hidden class="anchor" aria-hidden="true" href="#interface">#</a></h3>
<p>As a brief check that the method is working as expected and to make you acquainted with its interface let&rsquo;s identify a dummy experiment</p>
<p><code>input</code> must consist of at least three lists:</p>
<ul>
<li><code>base</code> is the basis event that stands as a denominator of conversion</li>
<li><code>target</code> is the goal event - conversion numerator</li>
<li><code>groups</code> are names of the experiment variants</li>
</ul>
<p>In addition <code>variant</code> is specified to explicitly define which group we&rsquo;re focus on (it makes sense in case of multivariate testing)</p>
<details>
<summary>Code</summary>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>input <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;base&#34;</span>: [
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">480</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">437</span>,
</span></span><span style="display:flex;"><span>    ],
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;target&#34;</span>: [
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">32</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">37</span>,
</span></span><span style="display:flex;"><span>    ],
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;groups&#34;</span>: [
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;test&#34;</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;control&#34;</span>,
</span></span><span style="display:flex;"><span>    ],
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;variant&#34;</span>: <span style="color:#e6db74">&#34;test&#34;</span>,
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></details>
<p>Functionality is written leveraging well-known OOP principles, so the experiment is not a function that stands aside, but a class which besides <code>input</code> dictionary gets the keys of the corresponding entities.</p>
<details>
<summary>Code</summary>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>test <span style="color:#f92672">=</span> Ztest(input, base<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;base&#34;</span>, target<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;target&#34;</span>, groups<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;groups&#34;</span>, variant<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;variant&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;p-value: </span><span style="color:#e6db74">{</span>test<span style="color:#f92672">.</span>variant_pvalue(alternative<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;less&#39;</span>)<span style="color:#e6db74">:</span><span style="color:#e6db74">.3f</span><span style="color:#e6db74">}</span><span style="color:#e6db74">, Z-statistic: </span><span style="color:#e6db74">{</span>test<span style="color:#f92672">.</span>statistic[<span style="color:#ae81ff">0</span>]<span style="color:#e6db74">:</span><span style="color:#e6db74">.3f</span><span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span></code></pre></div></details>
<pre><code>p-value: 0.151, Z-statistic: -1.032
</code></pre>
<p>For on the fly verification, the results might be compared to the output of well known <code>statsmodels</code> package.</p>
<details>
<summary>Code</summary>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>count <span style="color:#f92672">=</span> input[<span style="color:#e6db74">&#34;target&#34;</span>]
</span></span><span style="display:flex;"><span>nobs <span style="color:#f92672">=</span> input[<span style="color:#e6db74">&#34;base&#34;</span>]
</span></span><span style="display:flex;"><span>stat, pval <span style="color:#f92672">=</span> proportions_ztest(count, nobs, alternative<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;smaller&#39;</span>)
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#39;p-value: </span><span style="color:#e6db74">{0:0.3f}</span><span style="color:#e6db74">, Z-statistic: </span><span style="color:#e6db74">{1:0.3f}</span><span style="color:#e6db74">&#39;</span><span style="color:#f92672">.</span>format(pval, stat))
</span></span></code></pre></div></details>
<pre><code>p-value: 0.151, Z-statistic: -1.032
</code></pre>
<p>The numbers coincide and now we&rsquo;re ready to move to the main topic.</p>
<h2 id="theory">Theory<a hidden class="anchor" aria-hidden="true" href="#theory">#</a></h2>
<p>While often basic Z-test procedure is the appropriate option for AB analysis, it doesn&rsquo;t satisfy the genuine requirements for the statistical method when it comes to multiple hypothesis testing.
I hope you understand what is the problem in case of having $n$ independent metrics in your test: if you set up acceptable Type I error rate $\alpha$ for each of them then the total probability to get at least one significant difference (dabbed as FWER) under the conditions of the truth of the null hypothesis (which means no difference between the groups by design) would be not $\alpha$ but $1 - (1 - \alpha)^n$ what totally invalidates the procedure.</p>
<p>There are two possible scenarios: either we have multiple metrics that we want to compare across the test and control group or we have several testing groups that apply different treatment to customers.
Whilst the first option is more popular by a wide margin and has lots of solutions, the second one is often undercovered in the business industry and generally the same procedures are used.
If you apply any type of corrections for multiple testing you&rsquo;re already ahead of 80% of teams that don&rsquo;t, although what I want to show you is that the second scenario must be treated differently to extract more insights from your experiments.</p>
<p><a href="https://en.wikipedia.org/wiki/Dunnett%27s_test">Dunnet&rsquo;s test</a> is a multiple comparison procedure developed specifically to compare each of a number of treatment groups to a control one, extended original <a href="https://www.jstor.org/stable/2528490?origin=crossref">paper</a> was released in 1964. Dunnett&rsquo;s test is not a set aside procedure but more like an extension of monumental Student&rsquo;s T-test, for a specific design where every treatment group is compared to a single control one, which is leveraged to take into account the dependencies between comparisons. In case of proportions it&rsquo;s a Z-test, as long as we don&rsquo;t need to estimate variance for binomial distribution in addition to the probability of success.</p>
<p>The main trick is to calculate variance in a different way, just to remind you in case of a standard procedure statistic looks like</p>
<p>$$ Z = \frac{\hat{p}_1 - \hat{p}_2}{S\sqrt{\frac{1}{n_1} + \frac{1}{n_2}}} $$</p>
<p>where $S$ is a standard error estimate comprises the squared root of variance of a combined sample $\sigma^2 = P(1 - P)$</p>
<p>Dunnett&rsquo;s test statistic looks exactly the same for every treatment group with the only difference laying under how variance is calculated.
In general in case of $n$ treatment groups and one control group $i=0$ of observations $(X_0, .. X_{N_i})$ with $N_i$ size of each, the formula is the following:</p>
<p>$$ S^{2} = \frac{\sum_{i=0}^{n}S_i^2}{df} = \frac{\sum_{i=0}^{n}\sum_{j=1}^{N_i}(X_{ij} - \bar{X_i})^2}{df} = \frac{\sum_{i=0}^{n}\sum_{j=1}^{N_i}X_{ij}^2 - n\bar{X_i}^2}{df} $$</p>
<p>where $df$ is degrees of freedom</p>
<p>$$ df = \sum_{i=0}^{n}N_{i} - (n + 1) $$</p>
<p>For proportions this &ldquo;pooled&rdquo; variance simplifies even further as long as the rest part of calculations is exactly the same</p>
<p>$$ S^{2} = \frac{\sum_{i=0}^{n}{N_i\bar{p_i}(1 - \bar{p_i})}}{df} $$</p>
<h2 id="canonical-ab-test">Canonical AB test<a hidden class="anchor" aria-hidden="true" href="#canonical-ab-test">#</a></h2>
<p>First of all, to guarantee the accuracy we should challenge this specific criterion against a classical one in case when both of them are applicable - standard AB test.
What is good about proportions we can easily simulate the data in the blink of an eye, so we&rsquo;re setting up a simulation and employ Monte Carlo process to check two things:</p>
<ul>
<li>correctness - the criterion should meet the identified confidence level, which means that in case of AA comparison we should get Type I error in $\alpha$ percent of experiments</li>
<li>power - as it comes from the theory in case of only two groups Dunnett&rsquo;s test is equal to a classical Z-test, so shall we call the implementation out?</li>
</ul>
<p>In addition to point estimate of False Positive Rate I offer to build 90% confidence interval to be more precise in the comparisons</p>
<details>
<summary>Code</summary>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">generate_sample</span>(size: int, prob: float) <span style="color:#f92672">-&gt;</span> int:
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    Return the number of target events
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> binom(n<span style="color:#f92672">=</span>size, p<span style="color:#f92672">=</span>prob)<span style="color:#f92672">.</span>rvs()
</span></span></code></pre></div></details>
<h3 id="correctness-in-aa">Correctness in AA<a hidden class="anchor" aria-hidden="true" href="#correctness-in-aa">#</a></h3>
<details>
<summary>Code</summary>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>np<span style="color:#f92672">.</span>random<span style="color:#f92672">.</span>seed(<span style="color:#ae81ff">2024</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>alpha <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.05</span>
</span></span><span style="display:flex;"><span>n_iterations <span style="color:#f92672">=</span> <span style="color:#ae81ff">1000</span>
</span></span><span style="display:flex;"><span>p_general <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>input <span style="color:#f92672">=</span> dict<span style="color:#f92672">.</span>fromkeys([<span style="color:#e6db74">&#34;base&#34;</span>, <span style="color:#e6db74">&#34;target&#34;</span>, <span style="color:#e6db74">&#34;names&#34;</span>, <span style="color:#e6db74">&#34;variant&#34;</span>])
</span></span><span style="display:flex;"><span>input[<span style="color:#e6db74">&#34;names&#34;</span>] <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#34;A&#34;</span>, <span style="color:#e6db74">&#34;B&#34;</span>]
</span></span><span style="display:flex;"><span>input[<span style="color:#e6db74">&#34;variant&#34;</span>] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;B&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> size <span style="color:#f92672">in</span> map(int, [<span style="color:#ae81ff">1e2</span>, <span style="color:#ae81ff">1e3</span>, <span style="color:#ae81ff">1e4</span>]):
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    dunnett_positives <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    z_positives <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(n_iterations):
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        input[<span style="color:#e6db74">&#34;base&#34;</span>] <span style="color:#f92672">=</span> [size, size]
</span></span><span style="display:flex;"><span>        input[<span style="color:#e6db74">&#34;target&#34;</span>] <span style="color:#f92672">=</span> [generate_sample(size, p_general), generate_sample(size, p_general)]
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        dunnett_test <span style="color:#f92672">=</span> Dunnett(input, <span style="color:#e6db74">&#34;base&#34;</span>, <span style="color:#e6db74">&#34;target&#34;</span>, <span style="color:#e6db74">&#34;names&#34;</span>, <span style="color:#e6db74">&#34;variant&#34;</span>)
</span></span><span style="display:flex;"><span>        z_test <span style="color:#f92672">=</span> Ztest(input, <span style="color:#e6db74">&#34;base&#34;</span>, <span style="color:#e6db74">&#34;target&#34;</span>, <span style="color:#e6db74">&#34;names&#34;</span>, <span style="color:#e6db74">&#34;variant&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        dunnett_p_value <span style="color:#f92672">=</span> dunnett_test<span style="color:#f92672">.</span>variant_pvalue(alternative<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;two-sided&#34;</span>)
</span></span><span style="display:flex;"><span>        z_p_value <span style="color:#f92672">=</span> z_test<span style="color:#f92672">.</span>variant_pvalue(alternative<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;two-sided&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> dunnett_p_value <span style="color:#f92672">&lt;=</span> alpha:
</span></span><span style="display:flex;"><span>            dunnett_positives <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> z_p_value <span style="color:#f92672">&lt;=</span> alpha:
</span></span><span style="display:flex;"><span>            z_positives <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;FPR for sample size </span><span style="color:#e6db74">{</span>size<span style="color:#e6db74">}</span><span style="color:#e6db74">&#39;</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    l, r <span style="color:#f92672">=</span> proportion_confint(count<span style="color:#f92672">=</span>dunnett_positives, nobs<span style="color:#f92672">=</span>n_iterations, alpha<span style="color:#f92672">=</span><span style="color:#ae81ff">0.10</span>, method<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;wilson&#39;</span>)
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;Dunnet: </span><span style="color:#e6db74">{</span>dunnett_positives <span style="color:#f92672">/</span> n_iterations<span style="color:#e6db74">:</span><span style="color:#e6db74">.3f</span><span style="color:#e6db74">}</span><span style="color:#e6db74"> ± </span><span style="color:#e6db74">{</span>(r <span style="color:#f92672">-</span> l) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span><span style="color:#e6db74">:</span><span style="color:#e6db74">.3f</span><span style="color:#e6db74">}</span><span style="color:#e6db74">&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    l, r <span style="color:#f92672">=</span> proportion_confint(count<span style="color:#f92672">=</span>z_positives, nobs<span style="color:#f92672">=</span>n_iterations, alpha<span style="color:#f92672">=</span><span style="color:#ae81ff">0.10</span>, method<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;wilson&#39;</span>)
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;Z-test: </span><span style="color:#e6db74">{</span>z_positives <span style="color:#f92672">/</span> n_iterations<span style="color:#e6db74">:</span><span style="color:#e6db74">.3f</span><span style="color:#e6db74">}</span><span style="color:#e6db74"> ± </span><span style="color:#e6db74">{</span>(r <span style="color:#f92672">-</span> l) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span><span style="color:#e6db74">:</span><span style="color:#e6db74">.3f</span><span style="color:#e6db74">}</span><span style="color:#e6db74">&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    print()
</span></span><span style="display:flex;"><span>    
</span></span></code></pre></div></details>
<pre><code>FPR for sample size 100
Dunnet: 0.048 ± 0.011
Z-test: 0.048 ± 0.011

FPR for sample size 1000
Dunnet: 0.050 ± 0.011
Z-test: 0.050 ± 0.011

FPR for sample size 10000
Dunnet: 0.051 ± 0.011
Z-test: 0.051 ± 0.011
</code></pre>
<p>Amazing! It seems that 0.05 every time lies in the 90% confidence interval for FPR and hence the criterion is valid and moreover the numbers are exactly the same, it&rsquo;s what was expected and now let&rsquo;s check the power too.</p>
<h3 id="power-in-ab">Power in AB<a hidden class="anchor" aria-hidden="true" href="#power-in-ab">#</a></h3>
<details>
<summary>Code</summary>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>np<span style="color:#f92672">.</span>random<span style="color:#f92672">.</span>seed(<span style="color:#ae81ff">2024</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>alpha <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.05</span>
</span></span><span style="display:flex;"><span>n_iterations <span style="color:#f92672">=</span> <span style="color:#ae81ff">1000</span>
</span></span><span style="display:flex;"><span>p_general <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.10</span>
</span></span><span style="display:flex;"><span>effect_size <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.2</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>input <span style="color:#f92672">=</span> dict<span style="color:#f92672">.</span>fromkeys([<span style="color:#e6db74">&#34;base&#34;</span>, <span style="color:#e6db74">&#34;target&#34;</span>, <span style="color:#e6db74">&#34;names&#34;</span>, <span style="color:#e6db74">&#34;variant&#34;</span>])
</span></span><span style="display:flex;"><span>input[<span style="color:#e6db74">&#34;names&#34;</span>] <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#34;A&#34;</span>, <span style="color:#e6db74">&#34;B&#34;</span>]
</span></span><span style="display:flex;"><span>input[<span style="color:#e6db74">&#34;variant&#34;</span>] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;B&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> size <span style="color:#f92672">in</span> map(int, [<span style="color:#ae81ff">1e2</span>, <span style="color:#ae81ff">1e3</span>, <span style="color:#ae81ff">1e4</span>]):
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    dunnett_positives <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    z_positives <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(n_iterations):
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        input[<span style="color:#e6db74">&#34;base&#34;</span>] <span style="color:#f92672">=</span> [size, size]
</span></span><span style="display:flex;"><span>        input[<span style="color:#e6db74">&#34;target&#34;</span>] <span style="color:#f92672">=</span> [generate_sample(size, p_general), generate_sample(size, p_general <span style="color:#f92672">*</span> (<span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> effect_size))]
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        dunnett_test <span style="color:#f92672">=</span> Dunnett(input, <span style="color:#e6db74">&#34;base&#34;</span>, <span style="color:#e6db74">&#34;target&#34;</span>, <span style="color:#e6db74">&#34;names&#34;</span>, <span style="color:#e6db74">&#34;variant&#34;</span>)
</span></span><span style="display:flex;"><span>        z_test <span style="color:#f92672">=</span> Ztest(input, <span style="color:#e6db74">&#34;base&#34;</span>, <span style="color:#e6db74">&#34;target&#34;</span>, <span style="color:#e6db74">&#34;names&#34;</span>, <span style="color:#e6db74">&#34;variant&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        dunnett_p_value <span style="color:#f92672">=</span> dunnett_test<span style="color:#f92672">.</span>variant_pvalue(alternative<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;two-sided&#34;</span>)
</span></span><span style="display:flex;"><span>        z_p_value <span style="color:#f92672">=</span> z_test<span style="color:#f92672">.</span>variant_pvalue(alternative<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;two-sided&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> dunnett_p_value <span style="color:#f92672">&lt;=</span> alpha:
</span></span><span style="display:flex;"><span>            dunnett_positives <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> z_p_value <span style="color:#f92672">&lt;=</span> alpha:
</span></span><span style="display:flex;"><span>            z_positives <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;TPR of </span><span style="color:#e6db74">{</span>effect_size<span style="color:#e6db74">:</span><span style="color:#e6db74">.0%</span><span style="color:#e6db74">}</span><span style="color:#e6db74"> effect size for sample size </span><span style="color:#e6db74">{</span>size<span style="color:#e6db74">}</span><span style="color:#e6db74">&#39;</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    l, r <span style="color:#f92672">=</span> proportion_confint(count<span style="color:#f92672">=</span>dunnett_positives, nobs<span style="color:#f92672">=</span>n_iterations, alpha<span style="color:#f92672">=</span><span style="color:#ae81ff">0.10</span>, method<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;wilson&#39;</span>)
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;Dunnet: </span><span style="color:#e6db74">{</span>dunnett_positives <span style="color:#f92672">/</span> n_iterations<span style="color:#e6db74">:</span><span style="color:#e6db74">.3f</span><span style="color:#e6db74">}</span><span style="color:#e6db74"> ± </span><span style="color:#e6db74">{</span>(r <span style="color:#f92672">-</span> l) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span><span style="color:#e6db74">:</span><span style="color:#e6db74">.3f</span><span style="color:#e6db74">}</span><span style="color:#e6db74">&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    l, r <span style="color:#f92672">=</span> proportion_confint(count<span style="color:#f92672">=</span>z_positives, nobs<span style="color:#f92672">=</span>n_iterations, alpha<span style="color:#f92672">=</span><span style="color:#ae81ff">0.10</span>, method<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;wilson&#39;</span>)
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;Z-test: </span><span style="color:#e6db74">{</span>z_positives <span style="color:#f92672">/</span> n_iterations<span style="color:#e6db74">:</span><span style="color:#e6db74">.3f</span><span style="color:#e6db74">}</span><span style="color:#e6db74"> ± </span><span style="color:#e6db74">{</span>(r <span style="color:#f92672">-</span> l) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span><span style="color:#e6db74">:</span><span style="color:#e6db74">.3f</span><span style="color:#e6db74">}</span><span style="color:#e6db74">&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    print()
</span></span><span style="display:flex;"><span>    
</span></span></code></pre></div></details>
<pre><code>TPR of 20% effect size for sample size 100
Dunnet: 0.085 ± 0.015
Z-test: 0.085 ± 0.015

TPR of 20% effect size for sample size 1000
Dunnet: 0.306 ± 0.024
Z-test: 0.306 ± 0.024

TPR of 20% effect size for sample size 10000
Dunnet: 0.992 ± 0.005
Z-test: 0.992 ± 0.005
</code></pre>
<p>We are well on our way - the numbers are exactly the same, which means that in the case of 2 groups, Dunnett&rsquo;s test is at least as powerful as a standard procedure. It&rsquo;s time to challenge it in a way it&rsquo;s supposed to be used: meet multivariate testing!</p>
<h2 id="multivariate-abc">Multivariate ABC<a hidden class="anchor" aria-hidden="true" href="#multivariate-abc">#</a></h2>
<h3 id="monte-carlo">Monte Carlo<a hidden class="anchor" aria-hidden="true" href="#monte-carlo">#</a></h3>
<p>Now we will track how the criterion controls not a single FPR, but family-wise error rate (FWER) and what is more in order to continue the comparison with a classical Z-test the latter needs to have Bonferroni correction applied otherwise it wouldn&rsquo;t properly control FWER.</p>
<details>
<summary>Code</summary>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">fwe</span>(x: np<span style="color:#f92672">.</span>ndarray, alpha: float) <span style="color:#f92672">-&gt;</span> bool:
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    Indicates either at least one of null hypotheses is rejected
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> max(x <span style="color:#f92672">&lt;=</span> alpha)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">bonferroni_fwe</span>(x: np<span style="color:#f92672">.</span>ndarray, alpha: float, n: int) <span style="color:#f92672">-&gt;</span> bool:
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    Bonferroni correction for FWER, you can think of as it&#39;s Bonferroni-Holm procedure
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    Because to have a False Positive result it&#39;s necessary and sufficient that at least one of `n` p-values doesn&#39;t exceed `alpha` / `n`
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> fwe(x, alpha <span style="color:#f92672">/</span> n)
</span></span></code></pre></div></details>
<p>To simplify the code in the future Monte Carlo procedure is wrapped into a function with all the necessary parameters supplied as arguments.</p>
<details>
<summary>Code</summary>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">monte_carlo</span>(
</span></span><span style="display:flex;"><span>    aa_test: bool <span style="color:#f92672">=</span> <span style="color:#66d9ef">True</span>,
</span></span><span style="display:flex;"><span>    verbose: bool <span style="color:#f92672">=</span> <span style="color:#66d9ef">True</span>,
</span></span><span style="display:flex;"><span>    n_iterations: int <span style="color:#f92672">=</span> <span style="color:#ae81ff">1000</span>,
</span></span><span style="display:flex;"><span>    group_size: int <span style="color:#f92672">=</span> <span style="color:#ae81ff">100</span>,
</span></span><span style="display:flex;"><span>    n_groups: int <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>,
</span></span><span style="display:flex;"><span>    p_general: float <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.1</span>,
</span></span><span style="display:flex;"><span>    effect_size: float <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.2</span>,
</span></span><span style="display:flex;"><span>    alpha: float <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.05</span>,
</span></span><span style="display:flex;"><span>) <span style="color:#f92672">-&gt;</span> dict:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    input <span style="color:#f92672">=</span> dict<span style="color:#f92672">.</span>fromkeys([<span style="color:#e6db74">&#34;base&#34;</span>, <span style="color:#e6db74">&#34;target&#34;</span>, <span style="color:#e6db74">&#34;names&#34;</span>, <span style="color:#e6db74">&#34;variant&#34;</span>])
</span></span><span style="display:flex;"><span>    input[<span style="color:#e6db74">&#34;names&#34;</span>] <span style="color:#f92672">=</span> [chr(ord(<span style="color:#e6db74">&#34;A&#34;</span>) <span style="color:#f92672">+</span> i) <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(n_groups)]
</span></span><span style="display:flex;"><span>    input[<span style="color:#e6db74">&#34;variant&#34;</span>] <span style="color:#f92672">=</span> input[<span style="color:#e6db74">&#34;names&#34;</span>][<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    dunnett_positives <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    z_positives <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(n_iterations):
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        input[<span style="color:#e6db74">&#34;base&#34;</span>] <span style="color:#f92672">=</span> [group_size] <span style="color:#f92672">*</span> n_groups
</span></span><span style="display:flex;"><span>        input[<span style="color:#e6db74">&#34;target&#34;</span>] <span style="color:#f92672">=</span> [generate_sample(group_size, p_general) <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(n_groups <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)]
</span></span><span style="display:flex;"><span>        input[<span style="color:#e6db74">&#34;target&#34;</span>] <span style="color:#f92672">+=</span> [generate_sample(group_size, p_general <span style="color:#f92672">*</span> (<span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> effect_size <span style="color:#f92672">*</span> (<span style="color:#ae81ff">1</span> <span style="color:#f92672">-</span> aa_test)))]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        dunnett_test <span style="color:#f92672">=</span> Dunnett(input, <span style="color:#e6db74">&#34;base&#34;</span>, <span style="color:#e6db74">&#34;target&#34;</span>, <span style="color:#e6db74">&#34;names&#34;</span>, <span style="color:#e6db74">&#34;variant&#34;</span>)
</span></span><span style="display:flex;"><span>        z_test <span style="color:#f92672">=</span> Ztest(input, <span style="color:#e6db74">&#34;base&#34;</span>, <span style="color:#e6db74">&#34;target&#34;</span>, <span style="color:#e6db74">&#34;names&#34;</span>, <span style="color:#e6db74">&#34;variant&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        dunnett_p_value <span style="color:#f92672">=</span> dunnett_test<span style="color:#f92672">.</span>groups_results(alternative<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;two-sided&#34;</span>)[<span style="color:#e6db74">&#34;p-value&#34;</span>]
</span></span><span style="display:flex;"><span>        z_p_value <span style="color:#f92672">=</span> z_test<span style="color:#f92672">.</span>groups_results(alternative<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;two-sided&#34;</span>)[<span style="color:#e6db74">&#34;p-value&#34;</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> aa_test:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> fwe(dunnett_p_value, alpha):
</span></span><span style="display:flex;"><span>                dunnett_positives <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> bonferroni_fwe(z_p_value, alpha, <span style="color:#ae81ff">2</span>):
</span></span><span style="display:flex;"><span>                z_positives <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> isinstance(dunnett_p_value, np<span style="color:#f92672">.</span>ndarray) <span style="color:#f92672">and</span> dunnett_p_value[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">&lt;=</span> alpha:
</span></span><span style="display:flex;"><span>                dunnett_positives <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">elif</span> isinstance(dunnett_p_value, np<span style="color:#f92672">.</span>float64) <span style="color:#f92672">and</span> dunnett_p_value <span style="color:#f92672">&lt;=</span> alpha:
</span></span><span style="display:flex;"><span>                dunnett_positives <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> sidak_holm(z_p_value, alpha)[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]:
</span></span><span style="display:flex;"><span>                z_positives <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>    dl, dr <span style="color:#f92672">=</span> proportion_confint(count<span style="color:#f92672">=</span>dunnett_positives, nobs<span style="color:#f92672">=</span>n_iterations, alpha<span style="color:#f92672">=</span><span style="color:#ae81ff">0.10</span>, method<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;wilson&#39;</span>)
</span></span><span style="display:flex;"><span>    zl, zr <span style="color:#f92672">=</span> proportion_confint(count<span style="color:#f92672">=</span>z_positives, nobs<span style="color:#f92672">=</span>n_iterations, alpha<span style="color:#f92672">=</span><span style="color:#ae81ff">0.10</span>, method<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;wilson&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> verbose:
</span></span><span style="display:flex;"><span>        print (
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{</span><span style="color:#e6db74">&#39;FPR&#39;</span> <span style="color:#66d9ef">if</span> aa_test <span style="color:#66d9ef">else</span> <span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;TPR of </span><span style="color:#e6db74">{</span>effect_size<span style="color:#e6db74">:</span><span style="color:#e6db74">.0%</span><span style="color:#e6db74">}</span><span style="color:#e6db74"> effect size&#39;</span><span style="color:#e6db74">}</span><span style="color:#e6db74"> for sample size </span><span style="color:#e6db74">{</span>group_size<span style="color:#e6db74">}</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">f</span><span style="color:#e6db74">&#34; - Dunnett: </span><span style="color:#e6db74">{</span>dunnett_positives <span style="color:#f92672">/</span> n_iterations<span style="color:#e6db74">:</span><span style="color:#e6db74">.3f</span><span style="color:#e6db74">}</span><span style="color:#e6db74"> ± </span><span style="color:#e6db74">{</span>(dr <span style="color:#f92672">-</span> dl) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span><span style="color:#e6db74">:</span><span style="color:#e6db74">.3f</span><span style="color:#e6db74">}</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">f</span><span style="color:#e6db74">&#34; - Z-Test: </span><span style="color:#e6db74">{</span>z_positives <span style="color:#f92672">/</span> n_iterations<span style="color:#e6db74">:</span><span style="color:#e6db74">.3f</span><span style="color:#e6db74">}</span><span style="color:#e6db74"> ± </span><span style="color:#e6db74">{</span>(zr <span style="color:#f92672">-</span> zl) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span><span style="color:#e6db74">:</span><span style="color:#e6db74">.3f</span><span style="color:#e6db74">}</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>        )
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> {<span style="color:#e6db74">&#34;dunnett&#34;</span>: [dl, dunnett_positives <span style="color:#f92672">/</span> n_iterations, dr], <span style="color:#e6db74">&#34;z-test&#34;</span>: [zl, z_positives <span style="color:#f92672">/</span> n_iterations, zr]}
</span></span></code></pre></div></details>
<h3 id="correctness">Correctness<a hidden class="anchor" aria-hidden="true" href="#correctness">#</a></h3>
<p>Validity first, let&rsquo;s check the ability to control FWER at predefined $\alpha$ level.</p>
<details>
<summary>Code</summary>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>np<span style="color:#f92672">.</span>random<span style="color:#f92672">.</span>seed(<span style="color:#ae81ff">2024</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> size <span style="color:#f92672">in</span> [<span style="color:#ae81ff">1e2</span>, <span style="color:#ae81ff">5e2</span>, <span style="color:#ae81ff">1e3</span>, <span style="color:#ae81ff">5e3</span>]:
</span></span><span style="display:flex;"><span>    _ <span style="color:#f92672">=</span> monte_carlo(aa_test<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>, group_size<span style="color:#f92672">=</span>int(size))
</span></span></code></pre></div></details>
<pre><code>FPR for sample size 100
 - Dunnett: 0.045 ± 0.011
 - Z-Test: 0.042 ± 0.010

FPR for sample size 500
 - Dunnett: 0.048 ± 0.011
 - Z-Test: 0.045 ± 0.011

FPR for sample size 1000
 - Dunnett: 0.063 ± 0.013
 - Z-Test: 0.056 ± 0.012

FPR for sample size 5000
 - Dunnett: 0.050 ± 0.011
 - Z-Test: 0.046 ± 0.011
</code></pre>
<p>Super cool, both methods: Dunnett&rsquo;s Test without any corrections and Z-Test with Bonferroni-Holm correction control FWER correctly.</p>
<h3 id="power">Power<a hidden class="anchor" aria-hidden="true" href="#power">#</a></h3>
<p>Now it&rsquo;s the time to define a full fledged step-down procedure for multivariate testing as although its shortened version works well to define FWER it doesn&rsquo;t when it comes to a power analysis.
I prefer Sidak-Holm procedure as it&rsquo;s known as the most powerful procedure that controls FWER, however as long as sample size is increased the difference from Bonferroni-Holm is hardly noticeable.</p>
<details>
<summary>Code</summary>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">sidak_holm</span>(p_values: np<span style="color:#f92672">.</span>ndarray, alpha: float) <span style="color:#f92672">-&gt;</span> np<span style="color:#f92672">.</span>ndarray:
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    Step down Sidak-Holm procedure
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    If the statistics are jointly independent, no procedure can be constructed to control FWER that is more powerful than the Sidak-Holm method
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    m <span style="color:#f92672">=</span> p_values<span style="color:#f92672">.</span>size
</span></span><span style="display:flex;"><span>    adjusted_alpha <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>array([<span style="color:#ae81ff">1</span> <span style="color:#f92672">-</span> (<span style="color:#ae81ff">1</span> <span style="color:#f92672">-</span> alpha) <span style="color:#f92672">**</span> (<span style="color:#ae81ff">1</span> <span style="color:#f92672">/</span> (m <span style="color:#f92672">-</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)) <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, m <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)])
</span></span><span style="display:flex;"><span>    sorted_indexes <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>argsort(p_values)
</span></span><span style="display:flex;"><span>    sorted_pvalues <span style="color:#f92672">=</span> p_values[sorted_indexes]
</span></span><span style="display:flex;"><span>    first_reject <span style="color:#f92672">=</span> (list(sorted_pvalues <span style="color:#f92672">&lt;=</span> adjusted_alpha) <span style="color:#f92672">+</span> [<span style="color:#66d9ef">False</span>])<span style="color:#f92672">.</span>index(<span style="color:#66d9ef">False</span>)
</span></span><span style="display:flex;"><span>    result <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>array([<span style="color:#66d9ef">True</span>] <span style="color:#f92672">*</span> first_reject <span style="color:#f92672">+</span> [<span style="color:#66d9ef">False</span>] <span style="color:#f92672">*</span> (m <span style="color:#f92672">-</span> first_reject))
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> result[np<span style="color:#f92672">.</span>argsort(sorted_indexes)]
</span></span></code></pre></div></details>
<p>For the power test I offer to use two treatment groups and a single control where in one of the treatments an effect of 20% uplift is added. So the null hypothesis should be rejected and True Positive Rate is measured - is the share of rejected hypotheses among the number of iterations.</p>
<details>
<summary>Code</summary>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>np<span style="color:#f92672">.</span>random<span style="color:#f92672">.</span>seed(<span style="color:#ae81ff">2024</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> size <span style="color:#f92672">in</span> [<span style="color:#ae81ff">1e2</span>, <span style="color:#ae81ff">5e2</span>, <span style="color:#ae81ff">1e3</span>, <span style="color:#ae81ff">5e3</span>]:
</span></span><span style="display:flex;"><span>    _ <span style="color:#f92672">=</span> monte_carlo(aa_test<span style="color:#f92672">=</span><span style="color:#66d9ef">False</span>, group_size<span style="color:#f92672">=</span>int(size))
</span></span></code></pre></div></details>
<pre><code>TPR of 20% effect size for sample size 100
 - Dunnett: 0.051 ± 0.011
 - Z-Test: 0.043 ± 0.011

TPR of 20% effect size for sample size 500
 - Dunnett: 0.104 ± 0.016
 - Z-Test: 0.092 ± 0.015

TPR of 20% effect size for sample size 1000
 - Dunnett: 0.265 ± 0.023
 - Z-Test: 0.240 ± 0.022

TPR of 20% effect size for sample size 5000
 - Dunnett: 0.855 ± 0.018
 - Z-Test: 0.842 ± 0.019
</code></pre>
<p>The results are promising! The power of Dunnett&rsquo;s test every time exceeds the power of Z-test with Sidak-Holm procedure applied.
The difference is not significant though, so we can&rsquo;t say for sure that it&rsquo;s better, let&rsquo;s experiment more with parameters and change <code>effect_size</code></p>
<details>
<summary>Code</summary>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>np<span style="color:#f92672">.</span>random<span style="color:#f92672">.</span>seed(<span style="color:#ae81ff">2024</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> effect_size <span style="color:#f92672">in</span> [<span style="color:#ae81ff">0.1</span>, <span style="color:#ae81ff">0.2</span>, <span style="color:#ae81ff">0.3</span>]:
</span></span><span style="display:flex;"><span>    _ <span style="color:#f92672">=</span> monte_carlo(aa_test<span style="color:#f92672">=</span><span style="color:#66d9ef">False</span>, group_size<span style="color:#f92672">=</span><span style="color:#ae81ff">3000</span>, effect_size<span style="color:#f92672">=</span>effect_size)
</span></span></code></pre></div></details>
<pre><code>TPR of 10% effect size for sample size 3000
 - Dunnett: 0.163 ± 0.019
 - Z-Test: 0.157 ± 0.019

TPR of 20% effect size for sample size 3000
 - Dunnett: 0.589 ± 0.026
 - Z-Test: 0.569 ± 0.026

TPR of 30% effect size for sample size 3000
 - Dunnett: 0.927 ± 0.014
 - Z-Test: 0.914 ± 0.015
</code></pre>
<p>It&rsquo;s exciting, the result remains the same, and if we know that Sidak-Holm is the most powerful method that controls FWER for the general use case, we see now that Dunnett&rsquo;s at least not worse. Finally, the most appealing variable is the number of treatment groups, let&rsquo;s vary it too.</p>
<details>
<summary>Code</summary>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>np<span style="color:#f92672">.</span>random<span style="color:#f92672">.</span>seed(<span style="color:#ae81ff">2024</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> n_groups <span style="color:#f92672">in</span> [<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">7</span>]:
</span></span><span style="display:flex;"><span>    _ <span style="color:#f92672">=</span> monte_carlo(aa_test<span style="color:#f92672">=</span><span style="color:#66d9ef">False</span>, group_size<span style="color:#f92672">=</span><span style="color:#ae81ff">3000</span>, n_groups<span style="color:#f92672">=</span>n_groups)
</span></span></code></pre></div></details>
<pre><code>TPR of 20% effect size for sample size 3000
 - Dunnett: 0.608 ± 0.025
 - Z-Test: 0.601 ± 0.025

TPR of 20% effect size for sample size 3000
 - Dunnett: 0.544 ± 0.026
 - Z-Test: 0.506 ± 0.026

TPR of 20% effect size for sample size 3000
 - Dunnett: 0.464 ± 0.026
 - Z-Test: 0.424 ± 0.026
</code></pre>
<p>Now we&rsquo;ve nailed it! The number of groups is what affects the bottom line. The more groups are in the experiment - the more powerful Dunnett&rsquo;s Correction than Sidak-Holm.
So, let&rsquo;s build a title image for this article that illustrates how Dunnett&rsquo;s test outperforms the well-known step-down procedure as the number of treatment groups increases.</p>
<details>
<summary>Code</summary>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">from</span> tqdm.notebook <span style="color:#f92672">import</span> tqdm
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>np<span style="color:#f92672">.</span>random<span style="color:#f92672">.</span>seed(<span style="color:#ae81ff">2024</span>)
</span></span><span style="display:flex;"><span>ztest_values <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>dunnett_values <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> n_groups <span style="color:#f92672">in</span> tqdm(range(<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">16</span>)):
</span></span><span style="display:flex;"><span>    result <span style="color:#f92672">=</span> monte_carlo(aa_test<span style="color:#f92672">=</span><span style="color:#66d9ef">False</span>, verbose<span style="color:#f92672">=</span><span style="color:#66d9ef">False</span>, group_size<span style="color:#f92672">=</span><span style="color:#ae81ff">3000</span>, n_groups<span style="color:#f92672">=</span>n_groups)
</span></span><span style="display:flex;"><span>    dunnett_values<span style="color:#f92672">.</span>append(result[<span style="color:#e6db74">&#34;dunnett&#34;</span>])
</span></span><span style="display:flex;"><span>    ztest_values<span style="color:#f92672">.</span>append(result[<span style="color:#e6db74">&#34;z-test&#34;</span>])
</span></span></code></pre></div></details>
<p>Plotly is used for interactive visualization, hover over the image to see details.</p>
<details>
<summary>Code</summary>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> plotly.express <span style="color:#66d9ef">as</span> px
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> plotly.graph_objs <span style="color:#66d9ef">as</span> go
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">hex2rgba</span>(hex, alpha):
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    Convert plotly hex colors to rgb and enables transparency adjustment
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    col_hex <span style="color:#f92672">=</span> hex<span style="color:#f92672">.</span>lstrip(<span style="color:#e6db74">&#39;#&#39;</span>)
</span></span><span style="display:flex;"><span>    col_rgb <span style="color:#f92672">=</span> tuple(int(col_hex[i : i <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>], <span style="color:#ae81ff">16</span>) <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> (<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">4</span>))
</span></span><span style="display:flex;"><span>    col_rgb <span style="color:#f92672">+=</span> (alpha,)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#39;rgba&#39;</span> <span style="color:#f92672">+</span> str(col_rgb)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">get_new_color</span>(colors):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> <span style="color:#66d9ef">True</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> color <span style="color:#f92672">in</span> colors:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">yield</span> color
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>colors_list <span style="color:#f92672">=</span> px<span style="color:#f92672">.</span>colors<span style="color:#f92672">.</span>qualitative<span style="color:#f92672">.</span>Plotly
</span></span><span style="display:flex;"><span>rgba_colors <span style="color:#f92672">=</span> [hex2rgba(color, alpha<span style="color:#f92672">=</span><span style="color:#ae81ff">0.5</span>) <span style="color:#66d9ef">for</span> color <span style="color:#f92672">in</span> colors_list]
</span></span><span style="display:flex;"><span>palette <span style="color:#f92672">=</span> get_new_color(rgba_colors)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">add_chart</span>(figure, data, title):
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    x <span style="color:#f92672">=</span> list(range(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">15</span>))
</span></span><span style="display:flex;"><span>    color <span style="color:#f92672">=</span> next(palette)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    figure<span style="color:#f92672">.</span>add_trace(
</span></span><span style="display:flex;"><span>        go<span style="color:#f92672">.</span>Scatter(
</span></span><span style="display:flex;"><span>            name<span style="color:#f92672">=</span>title,
</span></span><span style="display:flex;"><span>            x<span style="color:#f92672">=</span>x,
</span></span><span style="display:flex;"><span>            y<span style="color:#f92672">=</span>[v[<span style="color:#ae81ff">1</span>] <span style="color:#66d9ef">for</span> v <span style="color:#f92672">in</span> data],
</span></span><span style="display:flex;"><span>            mode<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;lines&#39;</span>,
</span></span><span style="display:flex;"><span>            line<span style="color:#f92672">=</span>dict(color<span style="color:#f92672">=</span>color),
</span></span><span style="display:flex;"><span>        ),
</span></span><span style="display:flex;"><span>    )
</span></span><span style="display:flex;"><span>    figure<span style="color:#f92672">.</span>add_trace(
</span></span><span style="display:flex;"><span>        go<span style="color:#f92672">.</span>Scatter(
</span></span><span style="display:flex;"><span>            name<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;Upper Bound&#39;</span>,
</span></span><span style="display:flex;"><span>            x<span style="color:#f92672">=</span>x,
</span></span><span style="display:flex;"><span>            y<span style="color:#f92672">=</span>[v[<span style="color:#ae81ff">2</span>] <span style="color:#66d9ef">for</span> v <span style="color:#f92672">in</span> data],
</span></span><span style="display:flex;"><span>            mode<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;lines&#39;</span>,
</span></span><span style="display:flex;"><span>            line<span style="color:#f92672">=</span>dict(width<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>),
</span></span><span style="display:flex;"><span>            marker<span style="color:#f92672">=</span>dict(color<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;#444&#34;</span>),
</span></span><span style="display:flex;"><span>            hovertemplate<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;%</span><span style="color:#e6db74">{y:.3f}</span><span style="color:#e6db74">&#34;</span>,
</span></span><span style="display:flex;"><span>            showlegend<span style="color:#f92672">=</span><span style="color:#66d9ef">False</span>,
</span></span><span style="display:flex;"><span>        ),
</span></span><span style="display:flex;"><span>    )
</span></span><span style="display:flex;"><span>    figure<span style="color:#f92672">.</span>add_trace(
</span></span><span style="display:flex;"><span>        go<span style="color:#f92672">.</span>Scatter(
</span></span><span style="display:flex;"><span>            name<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;Lower Bound&#39;</span>,
</span></span><span style="display:flex;"><span>            x<span style="color:#f92672">=</span>x,
</span></span><span style="display:flex;"><span>            y<span style="color:#f92672">=</span>[v[<span style="color:#ae81ff">0</span>] <span style="color:#66d9ef">for</span> v <span style="color:#f92672">in</span> data],
</span></span><span style="display:flex;"><span>            mode<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;lines&#39;</span>,
</span></span><span style="display:flex;"><span>            line<span style="color:#f92672">=</span>dict(width<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>),
</span></span><span style="display:flex;"><span>            marker<span style="color:#f92672">=</span>dict(color<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;#444&#34;</span>),            
</span></span><span style="display:flex;"><span>            hovertemplate<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;%</span><span style="color:#e6db74">{y:.3f}</span><span style="color:#e6db74">&#34;</span>,
</span></span><span style="display:flex;"><span>            showlegend<span style="color:#f92672">=</span><span style="color:#66d9ef">False</span>,
</span></span><span style="display:flex;"><span>            fillcolor<span style="color:#f92672">=</span>color,
</span></span><span style="display:flex;"><span>            fill<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;tonexty&#39;</span>,
</span></span><span style="display:flex;"><span>        ),
</span></span><span style="display:flex;"><span>    )
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>figure <span style="color:#f92672">=</span> go<span style="color:#f92672">.</span>Figure()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>add_chart(figure, dunnett_values, <span style="color:#e6db74">&#34;Dunnnett&#39;s Correction&#34;</span>)
</span></span><span style="display:flex;"><span>add_chart(figure, ztest_values, <span style="color:#e6db74">&#39;Z-Test with Sidak-Holm&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>figure<span style="color:#f92672">.</span>update_xaxes(
</span></span><span style="display:flex;"><span>    title_text<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;Number of Treatment Groups&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>figure<span style="color:#f92672">.</span>update_layout(
</span></span><span style="display:flex;"><span>    yaxis_title<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;True Positive Rate&#39;</span>,
</span></span><span style="display:flex;"><span>    title<span style="color:#f92672">=</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;x&#34;</span>: <span style="color:#ae81ff">0.5</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;text&#34;</span>: <span style="color:#e6db74">&#39;Power of Сriterion&#39;</span>,
</span></span><span style="display:flex;"><span>    },
</span></span><span style="display:flex;"><span>    hovermode<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;x&#34;</span>,
</span></span><span style="display:flex;"><span>    template<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;plotly_dark&#34;</span>,
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>figure<span style="color:#f92672">.</span>show()
</span></span></code></pre></div></details>


<div id="plotly-001"></div>

<script>
  Plotly.newPlot(document.getElementById("plotly-001"), {"data":[{"line":{"color":"rgba(99, 110, 250, 0.5)"},"mode":"lines","name":"Dunnnett's Correction","type":"scatter","x":[1,2,3,4,5,6,7,8,9,10,11,12,13,14],"y":[0.688,0.592,0.57,0.549,0.496,0.514,0.448,0.463,0.475,0.432,0.431,0.4,0.417,0.389]},{"hovertemplate":"%{y:.3f}","line":{"width":0},"marker":{"color":"#444"},"mode":"lines","name":"Upper Bound","showlegend":false,"type":"scatter","x":[1,2,3,4,5,6,7,8,9,10,11,12,13,14],"y":[0.7115645275335323,0.6172818321555527,0.5955283369085665,0.5747154128280495,0.521982272609987,0.5399243774569618,0.47397215811258164,0.4890011261254521,0.5010073666097168,0.4579151302796451,0.45691066393709073,0.4257188161057409,0.44283689560022865,0.41462548885469463]},{"fill":"tonexty","fillcolor":"rgba(99, 110, 250, 0.5)","hovertemplate":"%{y:.3f}","line":{"width":0},"marker":{"color":"#444"},"mode":"lines","name":"Lower Bound","showlegend":false,"type":"scatter","x":[1,2,3,4,5,6,7,8,9,10,11,12,13,14],"y":[0.6634209330083176,0.5662216910883313,0.5440939090378668,0.523020159334454,0.470039313335931,0.48800007173232496,0.42230845918435345,0.43719854387429025,0.4491275455522712,0.4064518308009623,0.40546169362999623,0.3748208325422112,0.3916110127775716,0.3639735211445322]},{"line":{"color":"rgba(239, 85, 59, 0.5)"},"mode":"lines","name":"Z-Test with Sidak-Holm","type":"scatter","x":[1,2,3,4,5,6,7,8,9,10,11,12,13,14],"y":[0.688,0.58,0.534,0.495,0.453,0.455,0.398,0.403,0.404,0.363,0.373,0.34,0.345,0.323]},{"hovertemplate":"%{y:.3f}","line":{"width":0},"marker":{"color":"#444"},"mode":"lines","name":"Upper Bound","showlegend":false,"type":"scatter","x":[1,2,3,4,5,6,7,8,9,10,11,12,13,14],"y":[0.7115645275335323,0.6054227568941206,0.5598206130971541,0.5209845045940409,0.47898443668239743,0.48098861272274274,0.4237028442497031,0.42874194822906714,0.42974943930152476,0.38835073477285004,0.3984655404260462,0.3650421265587632,0.370114592424845,0.3477727663276548]},{"fill":"tonexty","fillcolor":"rgba(239, 85, 59, 0.5)","hovertemplate":"%{y:.3f}","line":{"width":0},"marker":{"color":"#444"},"mode":"lines","name":"Lower Bound","showlegend":false,"type":"scatter","x":[1,2,3,4,5,6,7,8,9,10,11,12,13,14],"y":[0.6634209330083176,0.5541455241875175,0.5079959063625421,0.46904247783835673,0.42726919818214004,0.4292542291688357,0.37284759737120804,0.3777815109594465,0.3787686234005093,0.33838858387484433,0.3482198133568529,0.3158213112779602,0.3207218629794807,0.2991824117792205]}],"layout":{"hovermode":"x","template":{"data":{"bar":[{"error_x":{"color":"#f2f5fa"},"error_y":{"color":"#f2f5fa"},"marker":{"line":{"color":"rgb(17,17,17)","width":0.5},"pattern":{"fillmode":"overlay","size":10,"solidity":0.2}},"type":"bar"}],"barpolar":[{"marker":{"line":{"color":"rgb(17,17,17)","width":0.5},"pattern":{"fillmode":"overlay","size":10,"solidity":0.2}},"type":"barpolar"}],"carpet":[{"aaxis":{"endlinecolor":"#A2B1C6","gridcolor":"#506784","linecolor":"#506784","minorgridcolor":"#506784","startlinecolor":"#A2B1C6"},"baxis":{"endlinecolor":"#A2B1C6","gridcolor":"#506784","linecolor":"#506784","minorgridcolor":"#506784","startlinecolor":"#A2B1C6"},"type":"carpet"}],"choropleth":[{"colorbar":{"outlinewidth":0,"ticks":""},"type":"choropleth"}],"contour":[{"colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1,"#f0f921"]],"type":"contour"}],"contourcarpet":[{"colorbar":{"outlinewidth":0,"ticks":""},"type":"contourcarpet"}],"heatmap":[{"colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1,"#f0f921"]],"type":"heatmap"}],"heatmapgl":[{"colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1,"#f0f921"]],"type":"heatmapgl"}],"histogram":[{"marker":{"pattern":{"fillmode":"overlay","size":10,"solidity":0.2}},"type":"histogram"}],"histogram2d":[{"colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1,"#f0f921"]],"type":"histogram2d"}],"histogram2dcontour":[{"colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1,"#f0f921"]],"type":"histogram2dcontour"}],"mesh3d":[{"colorbar":{"outlinewidth":0,"ticks":""},"type":"mesh3d"}],"parcoords":[{"line":{"colorbar":{"outlinewidth":0,"ticks":""}},"type":"parcoords"}],"pie":[{"automargin":true,"type":"pie"}],"scatter":[{"marker":{"line":{"color":"#283442"}},"type":"scatter"}],"scatter3d":[{"line":{"colorbar":{"outlinewidth":0,"ticks":""}},"marker":{"colorbar":{"outlinewidth":0,"ticks":""}},"type":"scatter3d"}],"scattercarpet":[{"marker":{"colorbar":{"outlinewidth":0,"ticks":""}},"type":"scattercarpet"}],"scattergeo":[{"marker":{"colorbar":{"outlinewidth":0,"ticks":""}},"type":"scattergeo"}],"scattergl":[{"marker":{"line":{"color":"#283442"}},"type":"scattergl"}],"scattermapbox":[{"marker":{"colorbar":{"outlinewidth":0,"ticks":""}},"type":"scattermapbox"}],"scatterpolar":[{"marker":{"colorbar":{"outlinewidth":0,"ticks":""}},"type":"scatterpolar"}],"scatterpolargl":[{"marker":{"colorbar":{"outlinewidth":0,"ticks":""}},"type":"scatterpolargl"}],"scatterternary":[{"marker":{"colorbar":{"outlinewidth":0,"ticks":""}},"type":"scatterternary"}],"surface":[{"colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1,"#f0f921"]],"type":"surface"}],"table":[{"cells":{"fill":{"color":"#506784"},"line":{"color":"rgb(17,17,17)"}},"header":{"fill":{"color":"#2a3f5f"},"line":{"color":"rgb(17,17,17)"}},"type":"table"}]},"layout":{"annotationdefaults":{"arrowcolor":"#f2f5fa","arrowhead":0,"arrowwidth":1},"autotypenumbers":"strict","coloraxis":{"colorbar":{"outlinewidth":0,"ticks":""}},"colorscale":{"diverging":[[0,"#8e0152"],[0.1,"#c51b7d"],[0.2,"#de77ae"],[0.3,"#f1b6da"],[0.4,"#fde0ef"],[0.5,"#f7f7f7"],[0.6,"#e6f5d0"],[0.7,"#b8e186"],[0.8,"#7fbc41"],[0.9,"#4d9221"],[1,"#276419"]],"sequential":[[0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1,"#f0f921"]],"sequentialminus":[[0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1,"#f0f921"]]},"colorway":["#636efa","#EF553B","#00cc96","#ab63fa","#FFA15A","#19d3f3","#FF6692","#B6E880","#FF97FF","#FECB52"],"font":{"color":"#f2f5fa"},"geo":{"bgcolor":"rgb(17,17,17)","lakecolor":"rgb(17,17,17)","landcolor":"rgb(17,17,17)","showlakes":true,"showland":true,"subunitcolor":"#506784"},"hoverlabel":{"align":"left"},"hovermode":"closest","mapbox":{"style":"dark"},"paper_bgcolor":"rgb(17,17,17)","plot_bgcolor":"rgb(17,17,17)","polar":{"angularaxis":{"gridcolor":"#506784","linecolor":"#506784","ticks":""},"bgcolor":"rgb(17,17,17)","radialaxis":{"gridcolor":"#506784","linecolor":"#506784","ticks":""}},"scene":{"xaxis":{"backgroundcolor":"rgb(17,17,17)","gridcolor":"#506784","gridwidth":2,"linecolor":"#506784","showbackground":true,"ticks":"","zerolinecolor":"#C8D4E3"},"yaxis":{"backgroundcolor":"rgb(17,17,17)","gridcolor":"#506784","gridwidth":2,"linecolor":"#506784","showbackground":true,"ticks":"","zerolinecolor":"#C8D4E3"},"zaxis":{"backgroundcolor":"rgb(17,17,17)","gridcolor":"#506784","gridwidth":2,"linecolor":"#506784","showbackground":true,"ticks":"","zerolinecolor":"#C8D4E3"}},"shapedefaults":{"line":{"color":"#f2f5fa"}},"sliderdefaults":{"bgcolor":"#C8D4E3","bordercolor":"rgb(17,17,17)","borderwidth":1,"tickwidth":0},"ternary":{"aaxis":{"gridcolor":"#506784","linecolor":"#506784","ticks":""},"baxis":{"gridcolor":"#506784","linecolor":"#506784","ticks":""},"bgcolor":"rgb(17,17,17)","caxis":{"gridcolor":"#506784","linecolor":"#506784","ticks":""}},"title":{"x":0.05},"updatemenudefaults":{"bgcolor":"#506784","borderwidth":0},"xaxis":{"automargin":true,"gridcolor":"#283442","linecolor":"#506784","ticks":"","title":{"standoff":15},"zerolinecolor":"#283442","zerolinewidth":2},"yaxis":{"automargin":true,"gridcolor":"#283442","linecolor":"#506784","ticks":"","title":{"standoff":15},"zerolinecolor":"#283442","zerolinewidth":2}}},"title":{"text":"Power of Сriterion","x":0.5},"xaxis":{"title":{"text":"Number of Treatment Groups"}},"yaxis":{"title":{"text":"True Positive Rate"}}}});
</script>
<h2 id="conclusion">Conclusion<a hidden class="anchor" aria-hidden="true" href="#conclusion">#</a></h2>
<p>It was shown that when the experiment design satisfies the premises of Dunnett&rsquo;s Test applicability (only $n$ comparisons of $n$ test groups against a single control) at least in a specific case of conversion metrics, Dunnett&rsquo;s correction is more powerful that the standard step-down procedures like Sidak-Holm.</p>
<p>While Dunnet&rsquo;s correction is a definite winner it doesn&rsquo;t mean that Sidak-Holm is abandoned from now on in our team, the proper design would be to use Dunnett&rsquo;s correction first for multivariate testing and Sidak-Holm procedure must be applied on top if there are multiple metrics to compare between the groups, which is often the case.</p>
<h2 id="additional-information">Additional Information<a hidden class="anchor" aria-hidden="true" href="#additional-information">#</a></h2>
<ol>
<li><a href="https://amstat.tandfonline.com/doi/abs/10.1080/01621459.1955.10501294?journalCode=uasa20">Original Paper from Journal of the American Statistical Association</a></li>
<li><a href="https://blog.analytics-toolkit.com/2017/multivariate-testing-practices-tools-mvt-abn-tests/">Multivariate Testing - Best Practices</a></li>
<li><a href="https://www.analytics-toolkit.com/glossary/dunnett%E2%80%99s-correction/">Dunnett&rsquo;s Correction in Analytics ToolKit</a></li>
<li><a href="https://en.wikipedia.org/wiki/Multiple_comparisons_problem">Multiple comparisons problem</a></li>
</ol>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>

<div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share Dunnett&#39;s Correction for ABC testing on twitter"
        href="https://twitter.com/intent/tweet/?text=Dunnett%27s%20Correction%20for%20ABC%20testing&amp;url=https%3a%2f%2fnpodlozhniy.github.io%2fposts%2fdunnett-correction%2f&amp;hashtags=">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-253.927,424.544c135.939,0 210.268,-112.643 210.268,-210.268c0,-3.218 0,-6.437 -0.153,-9.502c14.406,-10.421 26.973,-23.448 36.935,-38.314c-13.18,5.824 -27.433,9.809 -42.452,11.648c15.326,-9.196 26.973,-23.602 32.49,-40.92c-14.252,8.429 -30.038,14.56 -46.896,17.931c-13.487,-14.406 -32.644,-23.295 -53.946,-23.295c-40.767,0 -73.87,33.104 -73.87,73.87c0,5.824 0.613,11.494 1.992,16.858c-61.456,-3.065 -115.862,-32.49 -152.337,-77.241c-6.284,10.881 -9.962,23.601 -9.962,37.088c0,25.594 13.027,48.276 32.95,61.456c-12.107,-0.307 -23.448,-3.678 -33.41,-9.196l0,0.92c0,35.862 25.441,65.594 59.311,72.49c-6.13,1.686 -12.72,2.606 -19.464,2.606c-4.751,0 -9.348,-0.46 -13.946,-1.38c9.349,29.426 36.628,50.728 68.965,51.341c-25.287,19.771 -57.164,31.571 -91.8,31.571c-5.977,0 -11.801,-0.306 -17.625,-1.073c32.337,21.15 71.264,33.41 112.95,33.41Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Dunnett&#39;s Correction for ABC testing on linkedin"
        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fnpodlozhniy.github.io%2fposts%2fdunnett-correction%2f&amp;title=Dunnett%27s%20Correction%20for%20ABC%20testing&amp;summary=Dunnett%27s%20Correction%20for%20ABC%20testing&amp;source=https%3a%2f%2fnpodlozhniy.github.io%2fposts%2fdunnett-correction%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Dunnett&#39;s Correction for ABC testing on facebook"
        href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fnpodlozhniy.github.io%2fposts%2fdunnett-correction%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Dunnett&#39;s Correction for ABC testing on telegram"
        href="https://telegram.me/share/url?text=Dunnett%27s%20Correction%20for%20ABC%20testing&amp;url=https%3a%2f%2fnpodlozhniy.github.io%2fposts%2fdunnett-correction%2f">
        <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
            <path
                d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
        </svg>
    </a>
</div>

  </footer><div id="disqus_thread"></div>
<script>
	
    var disqus_config = function () {
    this.page.url = 'https:\/\/npodlozhniy.github.io\/posts\/dunnett-correction\/';  
    this.page.identifier = ''; 
	this.language = document.documentElement.lang; 
	};
 
    (function() { 
    var d = document, s = d.createElement('script');
    s.src = 'https://https-npodlozhniy-github-io-2.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
    })();
	
    document.addEventListener('theme-change', function(e) { 
		if (document.readyState == 'complete') {
			DISQUS.reset({ reload: true, config: disqus_config });
		}
	});

</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="https://npodlozhniy.github.io/">Nikita Podlozhniy</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }

		
		const event = new Event('theme-change');
		document.dispatchEvent(event)
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
